---
id: 2023-01-18-tree
title: tree
metaTitle: Tree | Anas's Digital Garden
metaDescription: tree | Anas's Digital Garden
createdDate: 2023-01-18
updatedDate: 2023-01-18
weekNumber: 202303
category: data_structures
tags: ["data_structures", "tree"]
---

# Tree

- A Tree is:
    - empty, or
    - a node with:
        - a key, and
        - a list of child trees.

## Terminology

- Root: top node in the tree
- A child has a line down directly from a parent
- Ancestor: parent, or parent of parent, etc.
- Descendant: child, or child of child, etc.
- Sibling: sharing the same parent
- Leaf : node with no children
- Interior node (non-leaf)
- Level: 1+ num edges between root and node
- Height: maximum depth of subtree node and farthest leaf
- Forest: collection of trees

```python
def Height(tree):
	if tree = nil:
		return 0
	return 1 + Max(Height(tree:left),Height(tree:right))
```

## Walking a Tree

- Depth-first: We completely traverse one sub-tree before exploring a sibling sub-tree.
- Breadth-first: We traverse all nodes at one level before progressing to the next level.

```python
def InOrderTraversal(tree):
	if tree = nil:
		return
	InOrderTraversal(tree.left)
	Print(tree.key)
	InOrderTraversal(tree.right)
```

```python
def PreOrderTraversal(tree):
	if tree = nil:
		return
	Print(tree.key)
	PreOrderTraversal(tree.left)
	PreOrderTraversal(tree.right)
```

```python
def PostOrderTraversal(tree):
	if tree = nil:
		return
	PostOrderTraversal(tree.left)
	PostOrderTraversal(tree.right)
	Print(tree.key)
```

```python
def LevelTraversal(tree):
	if tree = nil:
	 return

	Queue q
	q.Enqueue(tree)

	while not q.Empty():
		node = q.Dequeue()
		Print(node)
		if node.left != nil:
			q.Enqueue(node.left)
		if node.right != nil:
			q.Enqueue(node:right)
```

## Definition

A tree is a data structure where a node can zero or more **children**. Each node contains a **value**. Like graphs, the connection between nodes is called **edges**. A tree is a type of graph, but not all of them are trees.  
It starts with a **root** node and branch off with its **descendants**, and finally, there are **leaves**.

![tree-parts](./images/tree-parts.jpg)

## Properties of Trees

- The top-most node is called **root**.
- A node without children is called **leaf node** or **terminal node**.
- **Height (h)** of the tree is the distance (edge count) between the farthest leaf to the root.
  - A has a height of 3
  - I has a height of 0
- **Depth or level of a node** is the distance between the root and the node in question.
  - H has a depth of 2
  - B has a depth of 1

## Binary Trees

Trees nodes can have zero or more children. However, when a tree has at the most two children, then it's called binary tree.

### Full, Complete and Perfect Binary Trees

Depending on how nodes are arranged in a binary tree, it can be full, complete and perfect:

- **Full binary tree**: each node has exactly 0 or 2 children (but never 1).
- **Complete binary tree**: when all levels except the last one are full with nodes.
- **Perfect binary tree**: when all the levels (including the last one) are full of nodes.

Look at these examples:

![Full, Complete and Perfect binary trees](./images/full-complete-perfect-binary-tree.jpg)

These properties are not always mutually exclusive. You can have more than one:

- A perfect tree is always complete and full.
- Perfect binary trees have precisely \({2^k -1}\)nodes, where k is the last level of the tree (starting with 1).
- A complete tree is not always full.  
  Like in our “complete” example, since it has a parent with only one child. If we remove the rightmost gray node, then we would have a complete and full tree but not perfect.  
  A full tree is not always complete and perfect.

## BFS Notes

- level order (BFS, using queue)
- time complexity: O(n)
- space complexity: best: O(1), worst: O(n/2)=O(n)

## DFS Notes

- time complexity: O(n)
- space complexity: best: O(log n) - avg. height of tree worst: O(n)
- inorder (DFS: left, self, right)
- postorder (DFS: left, right, self)
- preorder (DFS: self, left, right)

## Binary search Trees: Bsts

### Implement

- insert // insert value into tree
- get_node_count // get count of values stored
- print_values // prints the values in the tree, from min to max
- delete_tree
- is_in_tree // returns true if given value exists in the tree
- get_height // returns the height in nodes (single node's height is 1)
- get_min // returns the minimum value stored in the tree
- get_max // returns the maximum value stored in the tree
- is_binary_search_tree
- delete_value
- get_successor // returns next-highest value in tree after given value, -1 if none

## References

- [adrianmejia.com](https://adrianmejia.com/data-structures-for-beginners-trees-binary-search-tree-tutorial/)
