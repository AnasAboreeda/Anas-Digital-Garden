---
id: 2023-01-18-1-two-sum
title: 1. Two Sum
metaTitle: 1 Two Sum | Anas's Digital Garden
metaDescription: 1 two sum | Anas's Digital Garden
createdDate: 2023-01-18
updatedDate: 2023-01-25
weekNumber: 202303
category: problems-solutions
tags: ["problems-solutions", Array, HashMap]
Acceptance Rate: 0.48
Accepted: 5649379
Algorithm: Iterate
By Myself: Yes
Created At: January 7, 2022 3:42 PM
Dificulty: very easy
Submissions: 11754589
Submit Count: 1
Total Time(m): 15
URL: <https://leetcode.com/problems/two-sum/>
Updated At: January 7, 2022 3:42 PM
---

# 1. Two Sum

## Problem Statement

Given an array of integers `nums` and an integer `target`, return *indices of the two numbers such that they add up to `target`*.

You may assume that each input would have ***exactly* one solution**, and you may not use the *same* element twice.

You can return the answer in any order.

**Example 1:**

```
Input: nums = [2,7,11,15], target = 9
Output: [0,1]
Output: Because nums[0] + nums[1] == 9, we return [0, 1].

```

**Example 2:**

```
Input: nums = [3,2,4], target = 6
Output: [1,2]

```

**Example 3:**

```
Input: nums = [3,3], target = 6
Output: [0,1]

```

**Constraints:**

- `2 <= nums.length <= 104`
- `109 <= nums[i] <= 109`
- `109 <= target <= 109`
- **Only one valid answer exists.**

**Follow-up:**

Can you come up with an algorithm that is less than

```
O(n2)
```

time complexity?

## Solution

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
      Map<Integer, Integer> cache = new HashMap<>();

      for (int i = 0; i < nums.length; i++) {
        int diff = target - nums[i];

        if (cache.containsKey(diff)) {
          return new int[] {cache.get(diff), i};
        }

        cache.put(nums[i], i);
      }
      return new int[] {};
    }
  }
```

## Time Complexity

O(n)

## Space Complexity

O(n)

## Explanation
